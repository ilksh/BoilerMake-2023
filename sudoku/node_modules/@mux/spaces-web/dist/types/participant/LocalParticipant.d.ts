/// <reference types="node" />
import { LocalTrack } from '../track/LocalTrack';
import { EventEmitter } from 'events';
import { ParticipantRole } from './enums';
import { CustomEvent } from '../space/types';
/**
 * A LocalParticipant is the local peer connected to the space.
 * Local participants can emit [[ParticipantEvent]] to allow you to respond
 * to state updates.
 *
 * @noInheritDoc
 */
export default class LocalParticipant extends EventEmitter {
    /**
     * The unique participant id derived from the `participant_id`
     * field in the JWT
     */
    id: string;
    /**
     * A unique connection id generated every time a participant connects
     * to a space
     */
    connectionId: string;
    private manager;
    /**
     * A map of all audio tracks on this participant
     */
    audioTracks: Map<string, LocalTrack>;
    /**
     * A map of all video tracks on this participant
     */
    videoTracks: Map<string, LocalTrack>;
    /**
     * The role for this participant in the space. This can be specified by the `role` field in the JWT.
     * If none is specificed, the default is [[ParticipantRole.Publisher]]
     */
    role: ParticipantRole;
    /**
     * Publishes a string payload to the space.
     * Emits [[SpaceEvent.ParticipantCustomEventPublished]] and [[ParticipantEvent.CustomEventPublished]] events
     * upon successfully completing the publish request to the space.
     * @param payload
     * @returns
     */
    publishCustomEvent(payload: string): Promise<CustomEvent>;
    /**
     * Validates if the tracks to be published are within the server limits for each {@link TrackSource}.
     * @param candidateTracks tracks to be published
     * @returns the first {@link TrackSource} in the array which is over the specified server limits, if one exists
     */
    private validatePublishTrackLimits;
    /**
     * publishTracks publishes an array of {@link LocalTrack} to
     * the space
     * @param tracks
     * @returns
     */
    publishTracks(tracks: LocalTrack[]): Promise<LocalTrack[]>;
    /**
     * updateTracks updates an array of {@link LocalTrack} based on
     * {@link TrackSource}. This replaces the underlying media being sent
     * to the space without the need to unpublish and republish tracks. This should
     * be used with {@link getDisplayMedia} to update a camera or microphone input.
     *
     * **Note:** If you pass a track source that isn't already published it will not be updated.
     * For example, say you are publishing a Camera source but not a Microphone source. If
     * you pass in a track with a source of [[TrackSource.Microphone]] nothing will happen.
     *
     * @param tracks
     * @returns all LocalTracks that were sucessfully updated
     */
    updateTracks(tracks: LocalTrack[]): LocalTrack[];
    /**
     * unpublishAllTracks unpublishes all media for a {@link LocalParticipant}
     * @param options - Options for unpublishing tracks
     * @param options.stop - Whether to stop tracks that are unpublished
     */
    unpublishAllTracks(options?: {
        stop: boolean;
    }): void;
    /**
     * unpublishTracks unpublishes a list of tracks from the space
     * @param tracks
     * @param options - Options for unpublishing tracks
     * @param options.stop - Whether to stop tracks that are unpublished
     */
    unpublishTracks(tracks: LocalTrack[], options?: {
        stop: boolean;
    }): void;
    /**
     * getVideoTracks returns all video tracks
     * for a participant
     *
     * @returns
     */
    getVideoTracks(): LocalTrack[];
    /**
     * getAudioTracks returns all audio tracks
     * for a participant
     *
     * @returns
     */
    getAudioTracks(): LocalTrack[];
    /**
     * getTracks returns all (video and audio) tracks
     * for a participant
     *
     * @returns
     */
    getTracks(): LocalTrack[];
    private hasLocalTrack;
    private addLocalTrack;
    /**
     * Updates existing track
     *
     * @param track
     *
     * @returns the track if update undefined otherwise
     */
    private updateTrack;
    private removeLocalTrack;
    private onMute;
    private onUnmute;
}
